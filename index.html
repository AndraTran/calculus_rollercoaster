<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Build Your Roller Coaster!</title>
<style>
  body{font-family:system-ui,Segoe UI,Arial;margin:12px}
  #ui{display:flex;gap:16px;margin-bottom:12px}
  .panel{padding:8px;border:1px solid #ddd;border-radius:6px}
  canvas{background:#fff;border:1px solid #ccc;cursor:crosshair;width: 100%;box-sizing: border-box;
  display: block;}
  .bad{color:#b00;font-weight:700}
  .good{color:green;font-weight:700}
  .warning{color:#f90;font-weight:700}
  button.small{padding:6px 8px;margin-top:6px}
  button.continue{padding:10px 20px;margin-top:10px;background:#ff4444;color:white;border:none;border-radius:6px;font-weight:bold;cursor:pointer;font-size:14px}
  button.continue:hover{background:#cc0000}
  .threshold-item{margin:4px 0;font-size:13px}
  #tooltip{position:absolute;background:rgba(0,0,0,0.85);color:white;padding:8px 12px;border-radius:6px;pointer-events:none;display:none;font-size:12px;line-height:1.5;z-index:1000;white-space:nowrap}
  #suggestions{margin-top:8px;padding:10px;background:#fff3cd;border:1px solid #ffc107;border-radius:6px;display:none; align-self:flex-start}
  #suggestions h4{margin:0 0 8px 0;color:#856404}
  #suggestions ul{margin:4px 0;padding-left:20px}
  #suggestions li{margin:4px 0;color:#856404;font-size:13px}
</style>
</head>
<body>
  <div style="display:flex;flex-direction:column;width:100%;align-items:center;text-align:center;margin-bottom:12px">
  <h2 style="margin-bottom:4px">Build Your Own Roller Coaster!</h2>
        <div style="font-size:14px;color:#666">A Calculus project by Ng·ªçc Tr√¢n, Uy√™n Tr√¢m, Tr√† Giang</div>
</div>
  <div id="ui">
    <div class="panel">
      <label><strong>Track:</strong>

        <select id="trackType">
          <option value="gauss">Gaussian hump</option>
          <option value="sine">Sine wave</option>
          <option value="cosine">Cosine wave</option>
          <option value="tanh">Tanh (S-shape)</option>
        </select>
      </label>
      <div id="params"></div>
      <div style="margin-top:6px">
        <label style="display:block;margin:6px 0">
        <strong>Initial Speed (m/s)</strong>
        <input id="v0" type="number" value="0" step="0.5" style="width:80px">
        <div style="font-size:11px;color:#666">Starting velocity at track begining</div>
    
        </label>
        <strong>Friction coefficient (J per m)</strong>
        <input id="cLoss" type="number" value="0.2" step="0.1" style="width:80px">
        <div style="font-size:11px;color:#666">Energy loss per meter travel</div>
        
      </label>
        <button id="recalc" class="small">Generate track</button>
        <button id="continueBtn" class="continue" style="display:none">Continue Anyway (Unsafe)</button>
      </div>
    </div>

    <div class="panel" style="width:280px">
      <div><strong>Safety Thresholds (Fixed)</strong></div>
      <div class="threshold-item">‚úì Vertical positive g: <strong>4.0g</strong> max</div>
      <div class="threshold-item">‚úì Negative g (airtime): <strong>-1.5g</strong> min</div>
      <div class="threshold-item">‚úì Lateral g: <strong>2.0g</strong> max</div>
      <div class="threshold-item">‚úì Tangential accel: <strong>1.5g</strong> max</div>
      <div style="margin-top:12px;padding-top:8px;border-top:1px solid #ddd">
        <div style="font-size:12px;margin-bottom:4px"><strong>Legend:</strong></div>
        <div style="font-size:12px">üü¢ Green = Safe</div>
        <div style="font-size:12px">üü° Yellow = Warning (80-100%)</div>
        <div style="font-size:12px">üî¥ Red = Danger (>100%)</div>
      </div>
      <div style="margin-top:8px"><span id="status" class="good">OK</span></div>
      
      
    </div>

    <div id="suggestions">
        <h4>üí° Safety Suggestions:</h4>
        <ul id="suggestionList"></ul>
      </div>
  </div>

  <canvas id="trackCanvas" width=900 height=300></canvas>

  <div id="tooltip"></div>

<script>
/* Fixed simulator with complete safety analysis */
const g = 9.81;
const N = 800;
const xStart = 0, xEnd = 60;

// Fixed safety thresholds
const MAX_POS_G = 4.0;
const MIN_NEG_G = -1.5;
const MAX_LAT_G = 2.0;
const MAX_TANG_G = 1.5;
const WARNING_FACTOR = 0.8;

// Scale presets
const SCALES = {
  small: { range: 4, buffer: 0.5 },
  medium: { range: 12, buffer: 1.5 },
  large: { range: 40, buffer: 4 },
  veryLarge: { range: 120, buffer: 10 }
};

const trackTypeEl = document.getElementById('trackType');
const paramsDiv = document.getElementById('params');
const recalcBtn = document.getElementById('recalc');
const v0El = document.getElementById('v0');
const cLossEl = document.getElementById('cLoss');
const statusEl = document.getElementById('status');
const continueBtn = document.getElementById('continueBtn');
const tooltip = document.getElementById('tooltip');
const suggestionsEl = document.getElementById('suggestions');
const suggestionListEl = document.getElementById('suggestionList');

const tc = document.getElementById('trackCanvas'), tcx = tc.getContext('2d');

let animHandle = null;
let smoothedAngle = 0;
let isPaused = false;
let canContinue = false;

function setParamsUI(){
  const t = trackTypeEl.value;
  paramsDiv.innerHTML = '';
  if(t==='gauss'){
    paramsDiv.innerHTML = `
      <label style="display:block;margin:6px 0">
        <strong>Height (m)</strong>
        <input id="h" type="number" value="6" step="0.5" style="width:80px">
        <div style="font-size:11px;color:#666">Maximum height of the hill</div>
      </label>
      <label style="display:block;margin:6px 0">
        <strong>Center Position (m)</strong>
        <input id="x0" type="number" value="30" step="1" style="width:80px">
        <div style="font-size:11px;color:#666">Horizontal position of hill peak</div>
      </label>
      <label style="display:block;margin:6px 0">
        <strong>Width (Sigma)</strong>
        <input id="sigma" type="number" value="6" step="0.5" style="width:80px">
        <div style="font-size:11px;color:#666">Controls how wide/gentle the hill is</div>
      </label>
    `;
  } else if(t==='sine' || t==='cosine'){
    paramsDiv.innerHTML = `
      <label style="display:block;margin:6px 0">
        <strong>Amplitude (m)</strong>
        <input id="A" type="number" value="3" step="0.2" style="width:80px">
        <div style="font-size:11px;color:#666">Height of waves (peak to center)</div>
      </label>
      <label style="display:block;margin:6px 0">
        <strong>Frequency (Wavenumber)</strong>
        <input id="k" type="number" value="0.3" step="0.01" style="width:80px">
        <div style="font-size:11px;color:#666">How many waves fit in the track</div>
      </label>
      <label style="display:block;margin:6px 0">
        <strong>Phase Shift</strong> (radians)
        <input id="phi" type="number" value="0" step="0.1" style="width:80px">
        <div style="font-size:11px;color:#666">Horizontal offset of wave pattern</div>
      </label>
    `;
  } else if(t==='tanh'){
    paramsDiv.innerHTML = `
      <label style="display:block;margin:6px 0">
        <strong>Amplitude (m)</strong>
        <input id="A" type="number" value="4" step="0.2" style="width:80px">
        <div style="font-size:11px;color:#666">Height difference between levels</div>
      </label>
      <label style="display:block;margin:6px 0">
        <strong>Center Position (m)</strong>
        <input id="x0" type="number" value="30" step="1" style="width:80px">
        <div style="font-size:11px;color:#666">Where the transition occurs</div>
      </label>
      <label style="display:block;margin:6px 0">
        <strong>Transition Scale</strong>
        <input id="scale" type="number" value="6" step="0.5" style="width:80px">
        <div style="font-size:11px;color:#666">How gradual the transition is</div>
      </label>
    `;
  }
}
trackTypeEl.addEventListener('change', setParamsUI);
setParamsUI();

function yOf(x){
  const t = trackTypeEl.value;
  if(t==='gauss'){
    const h = +document.getElementById('h').value, x0 = +document.getElementById('x0').value, sigma = +document.getElementById('sigma').value;
    return (h * Math.exp(- (x-x0)*(x-x0) / (2*sigma*sigma)));
  } else if(t==='sine'){
    const A = +document.getElementById('A').value, k = +document.getElementById('k').value, phi = +document.getElementById('phi').value;
    return A * Math.sin(k*x + phi);
  } else if(t==='cosine'){
    const A = +document.getElementById('A').value, k = +document.getElementById('k').value, phi = +document.getElementById('phi').value;
    return A * Math.cos(k*x + phi);
  } else if(t==='tanh'){
    const A = +document.getElementById('A').value, x0 = +document.getElementById('x0').value, scale = +document.getElementById('scale').value;
    return A * Math.tanh((x - x0)/scale);
  }
  return 0;
}

function analyticDerivatives(xs, ys){
  const y1 = new Array(N);
  const y2 = new Array(N);
  const t = trackTypeEl.value;
  if(t==='gauss'){
    const h = +document.getElementById('h').value, x0 = +document.getElementById('x0').value, sigma = +document.getElementById('sigma').value;
    for(let i=0;i<N;i++){
      const x = xs[i];
      const expc = Math.exp(- (x-x0)*(x-x0) / (2*sigma*sigma));
      const yprime = h * expc * (-(x-x0)/(sigma*sigma));
      const ydouble = h * expc * ( ((x-x0)*(x-x0))/(sigma*sigma*sigma*sigma) - 1/(sigma*sigma) );
      y1[i]=yprime; y2[i]=ydouble;
    }
    return {y1,y2};
  }
  if(t==='sine'){
    const A = +document.getElementById('A').value, k = +document.getElementById('k').value, phi = +document.getElementById('phi').value;
    for(let i=0;i<N;i++){
      const x = xs[i];
      y1[i] = A * k * Math.cos(k*x + phi);
      y2[i] = - A * k * k * Math.sin(k*x + phi);
    }
    return {y1,y2};
  }
  if(t==='cosine'){
    const A = +document.getElementById('A').value, k = +document.getElementById('k').value, phi = +document.getElementById('phi').value;
    for(let i=0;i<N;i++){
      const x = xs[i];
      y1[i] = - A * k * Math.sin(k*x + phi);
      y2[i] = - A * k * k * Math.cos(k*x + phi);
    }
    return {y1,y2};
  }
  if(t==='tanh'){
    const A = +document.getElementById('A').value, x0 = +document.getElementById('x0').value, scale = +document.getElementById('scale').value;
    for(let i=0;i<N;i++){
      const x = xs[i];
      const z = (x - x0)/scale;
      const coshZ = Math.cosh(z);
      const sech2 = 1 / (coshZ * coshZ);
      y1[i] = A * sech2 * (1/scale);
      y2[i] = A * (-2) * sech2 * Math.tanh(z) * (1/(scale*scale));
    }
    return {y1,y2};
  }
  for(let i=1;i<N-1;i++){
    const dx = xs[i+1]-xs[i-1];
    y1[i] = (ys[i+1]-ys[i-1]) / dx;
    y2[i] = (ys[i+1] - 2*ys[i] + ys[i-1]) / ((dx/2)*(dx/2));
  }
  y1[0]=y1[1]; y1[N-1]=y1[N-2];
  y2[0]=y2[1]; y2[N-1]=y2[N-2];
  return {y1,y2};
}

function sampleTrack(){
  const xs = new Array(N);
  const ys = new Array(N);
  for(let i=0;i<N;i++){
    const x = xStart + (xEnd-xStart)*i/(N-1);
    xs[i]=x; ys[i]=yOf(x);
  }
  return {xs, ys};
}

function selectScale(ys){
  let yMin = ys[0], yMax = ys[0];
  for(let i=1;i<ys.length;i++){
    if(ys[i] < yMin) yMin = ys[i];
    if(ys[i] > yMax) yMax = ys[i];
  }
  
  const trackRange = yMax - yMin;
  const midpoint = (yMin + yMax) / 2;
  
  let scaleType;
  if(trackRange <= 4){
    scaleType = SCALES.small;
  } else if(trackRange <= 12){
    scaleType = SCALES.medium;
  } else if(trackRange <= 40){
    scaleType = SCALES.large;
  } else {
    scaleType = SCALES.veryLarge;
  }
  
  const halfRange = (scaleType.range / 2) + scaleType.buffer;
  return {
    yMin: midpoint - halfRange,
    yMax: midpoint + halfRange
  };
}

function analyze(){
  const {xs, ys} = sampleTrack();
  const {y1,y2} = analyticDerivatives(xs, ys);

  const sArr = new Array(N);
  const vArr = new Array(N);
  const gVert = new Array(N);
  const gLat = new Array(N);
  const gTang = new Array(N);
  const theta = new Array(N);

  let s = 0;
  sArr[0]=0;
  for(let i=1;i<N;i++){
    const dx = xs[i]-xs[i-1];
    const s1 = Math.sqrt(1 + y1[i-1]*y1[i-1]);
    const s2 = Math.sqrt(1 + y1[i]*y1[i]);
    const ds = 0.5*(s1 + s2) * dx;
    s += ds; sArr[i]=s;
  }

  const v0 = Math.max(0, +v0El.value);
  const cLoss = Math.max(0, +cLossEl.value);
  const y0 = ys[0];

  for(let i=0;i<N;i++){
    const denom = Math.pow(1 + y1[i]*y1[i], 1.5);
    const kappa = Math.abs(y2[i]) / (denom || 1e-12);
    const rho = (kappa>1e-9) ? (1/kappa) : 1e9;
    const val = v0*v0 + 2*g*(y0 - ys[i]) - 2*cLoss*sArr[i];
    vArr[i]= Math.sqrt(Math.max(0,val));
    theta[i] = Math.atan(y1[i]);
    const ac = (rho>1e8) ? 0 : (vArr[i]*vArr[i]/rho);
    gVert[i] = Math.cos(theta[i]) + ac / g;
    gLat[i] = 0;
  }

  // Calculate tangential g
  for(let i=1;i<N-1;i++){
    const dt = (sArr[i+1] - sArr[i-1]) / ((vArr[i] + vArr[i+1] + vArr[i-1]) / 3 || 1);
    const dv = vArr[i+1] - vArr[i-1];
    gTang[i] = (dv / dt) / g;
  }
  gTang[0] = gTang[1];
  gTang[N-1] = gTang[N-2];

  return {xs, ys, sArr, vArr, gVert, gLat, gTang, theta, y1, y2};
}

function generateSuggestions(data){
  const suggestions = [];
  
  let maxPosG = -Infinity, minNegG = Infinity, maxTangG = 0;
  for(let i=0;i<N;i++){
    if(data.gVert[i] > maxPosG) maxPosG = data.gVert[i];
    if(data.gVert[i] < minNegG) minNegG = data.gVert[i];
    if(Math.abs(data.gTang[i]) > maxTangG) maxTangG = Math.abs(data.gTang[i]);
  }
  
  const t = trackTypeEl.value;
  const v0 = +v0El.value;
  const cLoss = +cLossEl.value;
  
  // High positive g (too much crushing force)
  if(maxPosG > MAX_POS_G){
    suggestions.push(`<strong>To improve the safety of the track, please try</strong>:`);
    
    if(t === 'gauss'){
      const h = +document.getElementById('h').value;
      const sigma = +document.getElementById('sigma').value;
      suggestions.push(`Reduce height: Try h = ${Math.max(1, h * 0.7).toFixed(1)}m (currently ${h}m)`);
      suggestions.push(`Increase sigma: Try sigma = ${(sigma * 1.3).toFixed(1)} (currently ${sigma}) to make curve gentler`);
    } else if(t === 'sine' || t === 'cosine'){
      const A = +document.getElementById('A').value;
      const k = +document.getElementById('k').value;
      suggestions.push(`Reduce amplitude: Try A = ${Math.max(0.5, A * 0.7).toFixed(1)}m (currently ${A}m)`);
      suggestions.push(`Reduce wavenumber: Try k = ${Math.max(0.1, k * 0.8).toFixed(2)} (currently ${k}) for gentler curves`);
    } else if(t === 'tanh'){
      const A = +document.getElementById('A').value;
      const scale = +document.getElementById('scale').value;
      suggestions.push(`Reduce amplitude: Try A = ${Math.max(0.5, A * 0.7).toFixed(1)}m (currently ${A}m)`);
      suggestions.push(`Increase scale: Try scale = ${(scale * 1.3).toFixed(1)} (currently ${scale}) for smoother transition`);
    }
    
    suggestions.push(`Increase friction: Try c = ${(cLoss + 0.2).toFixed(1)} J/m (currently ${cLoss}) to reduce speed`);
    if(v0 > 0){
      suggestions.push(`Reduce initial velocity: Try v0 = ${Math.max(0, v0 - 2).toFixed(1)} m/s (currently ${v0})`);
    }
  }
  
  // Negative g (airtime, passengers floating)
  if(minNegG < MIN_NEG_G){
    suggestions.push(`<strong>Excessive negative g-force (${minNegG.toFixed(1)}g)</strong>:`);
    
    if(v0 > 0){
      suggestions.push(`Reduce initial velocity: Try v0 = ${Math.max(0, v0 - 2).toFixed(1)} m/s (currently ${v0})`);
    }
    suggestions.push(`Increase friction: Try c = ${(cLoss + 0.2).toFixed(1)} J/m (currently ${cLoss})`);
    
    if(t === 'gauss'){
      const h = +document.getElementById('h').value;
      suggestions.push(`Reduce height: Try h = ${Math.max(1, h * 0.8).toFixed(1)}m (currently ${h}m) to prevent high-speed drops`);
    }
  }
  
  // High tangential g
  if(maxTangG > MAX_TANG_G){
    suggestions.push(`<strong>High tangential acceleration (${maxTangG.toFixed(1)}g)</strong>:`);
    suggestions.push(`Increase friction: Try c = ${(cLoss + 0.3).toFixed(1)} J/m (currently ${cLoss}) to smooth acceleration`);
    
    if(t === 'gauss'){
      const sigma = +document.getElementById('sigma').value;
      suggestions.push(`Increase sigma: Try sigma = ${(sigma * 1.4).toFixed(1)} (currently ${sigma}) for gradual slopes`);
    } else if(t === 'sine' || t === 'cosine'){
      const k = +document.getElementById('k').value;
      suggestions.push(`Reduce wavenumber: Try k = ${Math.max(0.1, k * 0.7).toFixed(2)} (currently ${k})`);
    } else if(t === 'tanh'){
      const scale = +document.getElementById('scale').value;
      suggestions.push(`Increase scale: Try scale = ${(scale * 1.4).toFixed(1)} (currently ${scale})`);
    }
  }
  
  return suggestions;
}

function interpolatePosition(data, s){
  let idx0 = 0;
  for(let i = 0; i < N - 1; i++){
    if(data.sArr[i] <= s && s <= data.sArr[i+1]){
      idx0 = i;
      break;
    }
  }
  
  if(idx0 >= N - 1) idx0 = N - 2;
  
  const idx1 = idx0 + 1;
  const s0 = data.sArr[idx0];
  const s1 = data.sArr[idx1];
  
  const t = (s1 - s0) > 1e-9 ? (s - s0) / (s1 - s0) : 0;
  
  const x = data.xs[idx0] + t * (data.xs[idx1] - data.xs[idx0]);
  const y = data.ys[idx0] + t * (data.ys[idx1] - data.ys[idx0]);
  
  const v = data.vArr[idx0] + t * (data.vArr[idx1] - data.vArr[idx0]);
  const gVert = data.gVert[idx0] + t * (data.gVert[idx1] - data.gVert[idx0]);
  const gLat = data.gLat[idx0] + t * (data.gLat[idx1] - data.gLat[idx0]);
  const gTang = data.gTang[idx0] + t * (data.gTang[idx1] - data.gTang[idx0]);
  const angle = Math.atan2(data.ys[idx1] - data.ys[idx0], data.xs[idx1] - data.xs[idx0]);
  
  return {x, y, v, gVert, gLat, gTang, angle, idx: idx0};
}

function getSafetyLevel(gVert, gLat, gTang){
  if(gVert > MAX_POS_G) return 'danger';
  if(gVert > MAX_POS_G * WARNING_FACTOR) return 'warning';
  if(gVert < MIN_NEG_G) return 'danger';
  if(gVert < MIN_NEG_G * WARNING_FACTOR) return 'warning';
  if(Math.abs(gLat) > MAX_LAT_G) return 'danger';
  if(Math.abs(gLat) > MAX_LAT_G * WARNING_FACTOR) return 'warning';
  if(Math.abs(gTang) > MAX_TANG_G) return 'danger';
  if(Math.abs(gTang) > MAX_TANG_G * WARNING_FACTOR) return 'warning';
  return 'safe';
}

function getSegmentColor(level){
  if(level === 'danger') return 'rgba(200,0,0,0.9)';
  if(level === 'warning') return 'rgba(255,180,0,0.9)';
  return 'rgba(0,160,0,0.6)';
}

function clearCanvas(c, ctx){ ctx.clearRect(0,0,c.width,c.height); }

function drawCart(ctx, x, y, angle, velocity, isUnsafe){
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  
  // Offset to rotate around bottom of cart (wheels position)
  ctx.translate(0, 6);
  
  if(isUnsafe){
    const gradient = ctx.createRadialGradient(0, -6, 0, 0, -6, 35);
    gradient.addColorStop(0, 'rgba(255, 100, 100, 0.6)');
    gradient.addColorStop(0.5, 'rgba(255, 50, 50, 0.3)');
    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(-35, -41, 70, 70);
  }
  
  if(velocity > 10){
    const streakCount = Math.min(5, Math.floor(velocity / 5));
    const streakLength = Math.min(40, velocity * 1.5);
    ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
    ctx.lineWidth = 2;
    for(let i = 0; i < streakCount; i++){
      const offset = -10 - (i * streakLength / streakCount);
      ctx.beginPath();
      ctx.moveTo(offset, -6);
      ctx.lineTo(offset - streakLength / streakCount, -6);
      ctx.stroke();
    }
  }
  
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.roundRect(-12, -12, 24, 12, 3);
  ctx.fill();
  
  ctx.fillStyle = '#ff6b6b';
  ctx.beginPath();
  ctx.arc(-6, -14, 4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.beginPath();
  ctx.arc(6, -14, 4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.restore();
  
  ctx.save();
  ctx.fillStyle = '#000';
  ctx.font = 'bold 11px sans-serif';
  const label = `v = ${velocity.toFixed(1)} m/s`;
  const metrics = ctx.measureText(label);
  ctx.fillText(label, x - metrics.width / 2, y - 20);
  ctx.restore();
}

function drawDangerWarning(ctx, gVert){
  let message = '';
  if(gVert > MAX_POS_G){
    message = `‚ö†Ô∏è DANGER: Passengers are being crushed!`;
  } else if(gVert < MIN_NEG_G){
    message = `‚ö†Ô∏è DANGER: Passengers are lifting out of seats!`;
  }
  
  if(message){
    ctx.save();
    ctx.fillStyle = 'rgba(255, 0, 0, 0.95)';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.font = 'bold 16px sans-serif';
    const metrics = ctx.measureText(message);
    const boxWidth = metrics.width + 20;
    const boxHeight = 30;
    const x = (tc.width - boxWidth) / 2;
    const y = 10;
    
    ctx.fillRect(x, y, boxWidth, boxHeight);
    ctx.strokeRect(x, y, boxWidth, boxHeight);
    
    ctx.fillStyle = '#fff';
    ctx.fillText(message, x + 10, y + 20);
    ctx.restore();
  }
}

function drawTrackAndAnimate(data){
  if(animHandle) { cancelAnimationFrame(animHandle); animHandle = null; }

  const pad = 20;
  const X = (x)=> pad + (tc.width-2*pad)*( (x - xStart)/(xEnd-xStart) );
  
  const scale = selectScale(data.ys);
  const yMin = scale.yMin;
  const yMax = scale.yMax;
  
  const Y = (y)=> tc.height - (pad + (tc.height-2*pad)*( (y - yMin)/(yMax-yMin || 1e-6) ));

  function redrawTrack(){
    clearCanvas(tc, tcx);
    
    tcx.strokeStyle = '#e0e0e0';
    tcx.lineWidth = 0.5;
    tcx.font = '10px sans-serif';
    tcx.fillStyle = '#888';
    
    const gridStep = (yMax - yMin) > 50 ? 20 : (yMax - yMin) > 20 ? 10 : (yMax - yMin) > 10 ? 5 : 2;
    const gridStart = Math.floor(yMin / gridStep) * gridStep;
    const gridEnd = Math.ceil(yMax / gridStep) * gridStep;
    
    for(let y = gridStart; y <= gridEnd; y += gridStep){
      const py = Y(y);
      tcx.beginPath();
      tcx.moveTo(pad, py);
      tcx.lineTo(tc.width - pad, py);
      tcx.stroke();
      tcx.fillText(y + 'm', 2, py - 2);
    }

    tcx.lineWidth = 2; tcx.beginPath();
    for(let i=0;i<N;i++){
      const px = X(data.xs[i]), py = Y(data.ys[i]);
      if(i===0) tcx.moveTo(px,py); else tcx.lineTo(px,py);
    }
    tcx.strokeStyle = '#222'; tcx.stroke();

    tcx.lineWidth = 6;
    for(let i=1;i<N;i++){
      const level = getSafetyLevel(data.gVert[i], data.gLat[i], data.gTang[i]);
      tcx.strokeStyle = getSegmentColor(level);
      tcx.beginPath();
      tcx.moveTo(X(data.xs[i-1]), Y(data.ys[i-1]));
      tcx.lineTo(X(data.xs[i]), Y(data.ys[i]));
      tcx.stroke();
    }
  }

  let unsafeCount=0, warningCount=0;
  for(let i=0;i<N;i++){
    const level = getSafetyLevel(data.gVert[i], data.gLat[i], data.gTang[i]);
    if(level === 'danger') unsafeCount++;
    if(level === 'warning') warningCount++;
  }
  
  let status = 'OK';
  let statusClass = 'good';
  if(unsafeCount > 0){
    status = `Unsafe at ${unsafeCount} points`;
    statusClass = 'bad';
    
    // Show suggestions
    const suggestions = generateSuggestions(data);
    if(suggestions.length > 0){
      suggestionListEl.innerHTML = suggestions.map(s => `<li>${s}</li>`).join('');
      suggestionsEl.style.display = 'block';
    }
  } else if(warningCount > 0){
    status = `Warning at ${warningCount} points`;
    statusClass = 'warning';
    
    // Show mild suggestions
    const suggestions = generateSuggestions(data);
    if(suggestions.length > 0){
      suggestionListEl.innerHTML = suggestions.map(s => `<li>${s}</li>`).join('');
      suggestionsEl.style.display = 'block';
    }
  } else {
    suggestionsEl.style.display = 'none';
  }
  statusEl.textContent = status;
  statusEl.className = statusClass;

  // Animation with interpolation
  let currentS = 0;
  let lastTime = null;
  const timeMultiplier = 2;
  smoothedAngle = data.theta[0];
  isPaused = false;
  canContinue = false;
  continueBtn.style.display = 'none';
  
  function step(timestamp){
    if(lastTime === null) lastTime = timestamp;
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    
    const pos = interpolatePosition(data, currentS);
    
    if(currentS >= data.sArr[N-1]){
      animHandle = null;
      return;
    }
    
    const level = getSafetyLevel(pos.gVert, pos.gLat, pos.gTang);
    
    if(level === 'danger' && !isPaused && !canContinue){
      isPaused = true;
      continueBtn.style.display = 'block';
    }
    
    if(!isPaused){
      currentS += pos.v * deltaTime * timeMultiplier;
    }
    
    const targetAngle = pos.angle;
    const smoothingFactor = 0.15;
    smoothedAngle = smoothedAngle + (targetAngle - smoothedAngle) * smoothingFactor;
    
    const isUnsafe = level === 'danger';
    
    redrawTrack();
    
    if(isPaused){
      drawDangerWarning(tcx, pos.gVert);
    }
    
    drawCart(tcx, X(pos.x), Y(pos.y), smoothedAngle, pos.v, isUnsafe);

    animHandle = requestAnimationFrame(step);
  }
  
  redrawTrack();
  animHandle = requestAnimationFrame(step);
}

tc.addEventListener('mousemove', (e)=>{
  const rect = tc.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  const pad = 20;
  const relX = (mouseX - pad) / (tc.width - 2*pad);
  
  if(relX < 0 || relX > 1){
    tooltip.style.display = 'none';
    return;
  }
  
  if(!window.currentData) return;
  
  const idx = Math.round(relX * (N - 1));
  const data = window.currentData;
  
  const x = data.xs[idx];
  const y = data.ys[idx];
  const v = data.vArr[idx];
  const gVert = data.gVert[idx];
  const gLat = data.gLat[idx];
  const gTang = data.gTang[idx];
  const level = getSafetyLevel(gVert, gLat, gTang);
  
  const statusIcon = level === 'safe' ? '‚úì' : level === 'warning' ? '‚ö†Ô∏è' : 'üî¥';
  const statusText = level === 'safe' ? 'Safe' : level === 'warning' ? 'Warning' : 'Danger';
  
  tooltip.innerHTML = `
    <strong>Position:</strong> x = ${x.toFixed(2)}m, y = ${y.toFixed(2)}m<br>
    <strong>Velocity:</strong> ${v.toFixed(2)} m/s<br>
    <strong>Vertical g:</strong> ${gVert >= 0 ? '+' : ''}${gVert.toFixed(2)}g ${gVert > MAX_POS_G || gVert < MIN_NEG_G ? 'üî¥' : gVert > MAX_POS_G * WARNING_FACTOR || gVert < MIN_NEG_G * WARNING_FACTOR ? '‚ö†Ô∏è' : '‚úì'}<br>
    <strong>Lateral g:</strong> ${gLat >= 0 ? '+' : ''}${gLat.toFixed(2)}g ‚úì<br>
    <strong>Tangential g:</strong> ${gTang >= 0 ? '+' : ''}${gTang.toFixed(2)}g ${Math.abs(gTang) > MAX_TANG_G ? 'üî¥' : Math.abs(gTang) > MAX_TANG_G * WARNING_FACTOR ? '‚ö†Ô∏è' : '‚úì'}<br>
    <strong>Status:</strong> ${statusIcon} ${statusText}
  `;
  
  tooltip.style.display = 'block';
  tooltip.style.left = (e.clientX + 15) + 'px';
  tooltip.style.top = (e.clientY + 15) + 'px';
});

tc.addEventListener('mouseleave', ()=>{
  tooltip.style.display = 'none';
});

continueBtn.addEventListener('click', ()=>{
  isPaused = false;
  canContinue = true;
  continueBtn.style.display = 'none';
});

function recomputeAndDraw(){
  if(animHandle){ cancelAnimationFrame(animHandle); animHandle = null; }
        
    tc.width = window.innerWidth;
    // tc.height = window.innerHeight
                
  const data = analyze();
  window.currentData = data;
  drawTrackAndAnimate(data);
}

recalcBtn.addEventListener('click', recomputeAndDraw);

recomputeAndDraw();
</script>
</body>
</html>